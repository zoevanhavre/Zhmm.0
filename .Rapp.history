p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='grey',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='pink',position=position_dodge(width=0.8))
p2
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='pink',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',position=position_dodge(width=0.8))
p2
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',position=position_dodge(width=0.8))
p2
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
par(mfrow=c(2,1))
HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
HmmAllocationPlot(outZ=grunK0us$Z[,-1], myY=Y)
postPredTests<-PostPredFunk( grunK0us,Zetc, Y, 10, simlabel)
postPredTests$ggp
PostPredFunk( grunK0us,Zetc, Y, 100, simlabel)
#? maybe#
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
#
## 4. Predict replicates#
        postPredTests<-PostPredFunk( grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp
plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])
ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time")
plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time")
p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=2)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time")
p5
p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time")
p5
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red',position=position_dodge(width=0.8))#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',position=position_dodge(width=0.8))
print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red',position=position_dodge(width=0.8))#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',position=position_dodge(width=0.8))
print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))
position_dodge(width=0.8)
ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+
geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red')
ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red',vjust = 1)
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red',vjust = 1)#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',vjust = 1)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),
dev.off()
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)), col='red',vjust = 1)#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=6,  col='red',vjust = 1)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)),size=2,  col='red',vjust = 1)#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=2,  col='red',vjust = 1)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=8, height=6)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote( atop(italic( paste(.(simlabel) , ", K=", .(K0[.K0]) ) ), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=8, height=6)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=8, height=4)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=6)
print( wq::layOut(  list(p1,    1, 1:2),
list(p2,    1, 3:4),
list(p3,    1,5:6),
list(p5,    2,1:3),
list(p4,    2,4:6)))
dev.off()
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
pdf(file="TESTIIING.pdf")
p1
dev.off()
?wq
?layout
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic(paste("Results for K=", .(K0[.K0]), sep=""), atop("Means"))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic(paste("Results for K=", .(K0[.K0]), sep=""), atop("Means")))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic(paste("Results for K=", .(K0[.K0]), sep=""), atop("Means")))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
p2
dev.off()
p2
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+
ggtitle( bquote( atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+
geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+#
        ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+#
         geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
#
p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+#
        ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+#
     geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)
p1      #Allocations
p2
print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Allocation Probabilities", size=1)+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Allocation Probabilities", cex=1)+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Allocation Probabilities")+ #
            xlab("index of ordered y")+theme(plot.title = element_text(size=10 ))#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
#
        ## 4. Predict
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+theme(plot.title = element_text(size=12))+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+theme(plot.title = element_text(size=8))+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
p3
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + geom_tile()+ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+theme(plot.title = element_text(size=4))+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+theme_bw()+theme(legend.position='right')#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
    pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + #
            geom_tile()+#
            theme(legend.position='right', plot.title = element_text(size=4))+#
            ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+#
            theme_bw()#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
p3
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + #
            geom_tile()+#
            theme(legend.position='right', plot.title = element_text(size=1))+#
            ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+#
            theme_bw()#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + #
            geom_tile()+#
            theme(legend.position='right', plot.title = element_text(size=0.5))+#
            ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+#
            theme_bw()#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
HmmAllocationPlot<-function( outZ, myY){#
            grr<-outZ[,order(myY)]#
            grrTable<-data.frame("myY"=NULL, "k"=NULL, "Prob"=NULL)#
            #maxK<- length(levels(grr))#
            maxK<-max(grr)#
            for (i in 1:length(myY)){#
            #rr<-factor(grr[i], levels=1:maxK)#
            rr<-factor(grr[,i], levels=1:maxK)#
            grrTable<-rbind(grrTable,cbind(i,c(1:maxK), matrix(table(rr)/ length(rr) )))#
                }#
            names(grrTable)<-c("myY", "k", "Prob")#
                grrTable$k<-as.factor(grrTable$k)#
#
            gp<-ggplot(grrTable, aes(x=myY, y=k, fill=Prob)) + #
            geom_tile()+#
            theme(legend.position='right', plot.title = element_text(size=0.5,vjust=2))+#
            ggtitle("Posterior Allocation Probabilities")+ #
            xlab("index of ordered y")+#
            scale_fill_gradientn(colours = c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494" ))+#
            theme_bw()#
            #ggsave( plot=gp,  filename=paste( "Allocations_", plotfilename ,"K_",maxK, ".pdf",sep="") )#
            gp#
            }
p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)
p3
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
png( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)
print( wq::layOut(  list(p1,    1, 1:2),
list(p2,    1, 3:4),
list(p3,    1,5:6),
list(p5,    2,1:3),
list(p4,    2,4:6)))
dev.off()
png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=10, height=5)
print( wq::layOut(  list(p1,    1, 1:2),
list(p2,    1, 3:4),
list(p3,    1,5:6),
list(p5,    2,1:3),
list(p4,    2,4:6)))
dev.off()
png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=500, height=300)
print( wq::layOut(  list(p1,    1, 1:2),
list(p2,    1, 3:4),
list(p3,    1,5:6),
list(p5,    2,1:3),
list(p4,    2,4:6)))
dev.off()
png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)
print( wq::layOut(  list(p1,    1, 1:2),
list(p2,    1, 3:4),
list(p3,    1,5:6),
list(p5,    2,1:3),
list(p4,    2,4:6)))
dev.off()
.GrunK0us<-grunK0us
.Zetc<-Zetc
.Zetc<-Zetc
.Y<-Y
.prep<-prep
.prep<-10
#Y<-.GrunK0us$Y#
                n<-length(.Y)#
                K<- max(.GrunK0us$Pars$k)#
               .GrunK0us$Pars$k<-factor(.GrunK0us$Pars$k, levels=c(1:max(.GrunK0us$Pars$k)))#
                #swq0<- reshape(.GrunK0us$Pars, v.names="q0", idvar="Iteration", timevar="k", direction='wide')[,-1]#
                #swMeans<- reshape(.GrunK0us$Pars, v.names="mu", idvar="Iteration", timevar="k", direction='wide')[,-1]
K
.iters<-sample(c(1:max(.GrunK0us$Pars$Iteration)), size=.prep, replace = T, prob = NULL)
.iters
1130
.iters[1]
x<-.iters[1]
drawPars<-subset(.GrunK0us$Pars, Iteration==x)
drawPars
subset(.GrunK0us$Pars, Iteration==x)
subset(.GrunK0us$Pars, Iteration==10)
subset(.GrunK0us$Pars, Iteration==11)
round(subset(.GrunK0us$Pars, Iteration==11), 4)
round(subset(.GrunK0us$Pars, Iteration==11), 4)[,5:8]
round(subset(.GrunK0us$Pars, Iteration==11)[,5:8],4)
round(subset(.GrunK0us$Pars, Iteration==11)[,5:7],4)
round(subset(.GrunK0us$Pars, Iteration==1:10)[,5:7],4)
round(subset(.GrunK0us$Pars, Iteration==1)[,5:7],4)
round(subset(.GrunK0us$Pars, Iteration==2)[,5:7],4)
pdf(file=paste(simlabel, "_MCMCpp.pdf",sep='') ,width=8, height=3)#
    par(mfrow=c(1, 3))#
    barplot(slices, ylim=c(0,1), main="Estmated K_0", xlab="Number of non-empty states", ylab="Probability (from MCMC)") #
    abline(h=seq(0, 1, .05), lwd=0.5, col='LightGrey')#
    smoothScatter(both, colramp = Lab.palette, main="Posterior Surface", nrpoints = 0, xlab="Mean", ylab="Stationary dist.")#
    plot(both, col=trancol, xlim=minmaxMEANS, xlab="Mean", ylab="Stationary Distribution", bg='grey', main="Posterior Samples")#
    if(is.na(trueValues)==FALSE){   points(trueValues, pch=7, cex=2)}#
dev.off()
Zetc
round(aggregate( value~variable+factor(k), mean ,data=.par)[,3], 2)
round(aggregate( value~variable+factor(k), mean ,data=grunK0us)[,3], 2)
USout<-grunK0us
.par <- melt(USout$Pars, id.vars = c("Iteration", "k"))
theta <- aggregate(value ~ variable + factor(k), mean, data = .par)
theta
round(aggregate( value~variable+factor(k), mean ,data=.par)[,3], 2)
ci<-round(aggregate( value~variable+factor(k), quantile,c(0.025, 0.975) ,data=.par)[,3],2)
mu<-round(aggregate( value~variable+factor(k), mean ,data=.par)[,3], 2)
thetaCI<-cbind( theta[,c(1,2)] , "value"=paste( mu, "(", ci[,1] , "," ,ci[,2] ,")", sep="" ))
thetaCI
thetaCI<-cbind( theta[,c(1,2)] , "value"=paste( mu, "(", ci[,1] , "," ,ci[,2] ,")", sep=" " ))
thetaCI
theta <- aggregate(value ~  factor(k)+variable , mean, data = .par)
theta
theta<-aggregate( value~factor(k)+variable, mean ,data=.par)#
        mu<-round(aggregate( value~factor(k)+variable, mean ,data=.par)[,3], 2)#
        ci<-round(aggregate( value~factor(k)+variable, quantile,c(0.025, 0.975) ,data=.par)[,3],2)#
        thetaCI<-cbind( theta[,c(1,2)] , "value"=paste( mu, "(", ci[,1] , "," ,ci[,2] ,")", sep=" " ))
thetaCI
#' Processing output of label switching function#
#'#
#' explain here#
#' @param output of HMM label switching function, computes parameter estimates and some error values. #
#' @keywords postprocessing#
#' @export#
#' @examples#
#' #nope#
#
Zagg_HMM<-function(USout, .Y = Y) {#
.par <- melt(USout$Pars, id.vars = c("Iteration", "k"))#
theta <- aggregate(value ~  factor(k)+variable , mean, data = .par)#
#
        theta<-aggregate( value~factor(k)+variable, mean ,data=.par)#
        mu<-round(aggregate( value~factor(k)+variable, mean ,data=.par)[,3], 2)#
        ci<-round(aggregate( value~factor(k)+variable, quantile,c(0.025, 0.975) ,data=.par)[,3],2)#
        thetaCI<-cbind( theta[,c(1,2)] , "value"=paste( mu, "(", ci[,1] , "," ,ci[,2] ,")", sep=" " ))#
#
K <- max(.par$k)#
Zhat<- factor( apply(USout$Z, 2,maxZ))[-((length(.Y))+1)]#
Zemu <- as.numeric(Zhat)#
.Mus <- theta$value[theta$variable == "mu"]#
for (i in 1:length(Zemu)) { Zemu[i] <- .Mus[as.numeric(Zhat[i])]  }#
MSE <- sum((.Y - Zemu)^2)#
MAE <- sum(abs(.Y - Zemu))#
list(theta = theta, thetaCI=thetaCI, Zpred = Zhat, MSE = MSE, MAE = MAE)#
                }
Zetc<-Zagg_HMM(grunK0us, Y)
K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])
K0estimates
K<-dim(Run$q0)[2]#
    K0<-run$K0[burn:length(run$K0)]#
    K0estimates<-vector("list", length(K0))#
    Zestimates<-vector("list", length(K0))#
    USfullrun<-vector("list", length(K0))#
    # distribution of $K_0$#
    emptyK<-run$K0[burn:length(run$K0)]#
    # parameters by stationary dist#
    both<-cbind(melt(run$Means[-c(1:burn),])[,3], melt(run$q0[-c(1:burn),])[,3])#
    color <- as.factor(melt(run$Means[-c(1:burn),])[,2])#
    raincol<-rainbow(length(levels(color)));    levels(color)<-raincol#
    trancol<-sapply(c(1:length(color)), function(x) adjustcolor(color[x], alpha.f=both[x,2]))#
    minmaxMEANS<-c(min(both[both[,2]>minq4PLOT ,1]), max(both[both[,2]>minq4PLOT ,1]))
# unswitch seperate groups and make indi plots#
Y<-run$YZ$Obs#
Grun<-TrimThin(run, burn, Thin=1)       #
targetK0<-Grun$K0#
K0<-as.numeric(names(table(targetK0 )))#
    n<-length(Y)  #
    K<-dim(Grun$q0)[2]  #
    p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0)/dim(Grun$q0)[1]), "RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)#
        grunK0<-Grun
.K0
.iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred
}
#RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk( grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance
p_vals
print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))
.K0<-2
.iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred#
        #RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk( grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance        #
        # print plot#
        #pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
        png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()
}
Zetc$Zpred[-(n+1)]
length([-(n+1)]))
lengthZetc$Zpred[-(n+1)])
length(Zetc$Zpred[-(n+1)])
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
Zhmm_PP<-function( run , burn=1000, prep=1000, isSim=TRUE,trueValues=NA, minq4PLOT=0.0, simlabel="sim"){#
    K<-dim(Run$q0)[2]#
    K0<-run$K0[burn:length(run$K0)]#
    K0estimates<-vector("list", length(K0))#
    Zestimates<-vector("list", length(K0))#
    USfullrun<-vector("list", length(K0))#
    # distribution of $K_0$#
    emptyK<-run$K0[burn:length(run$K0)]#
    # parameters by stationary dist#
    both<-cbind(melt(run$Means[-c(1:burn),])[,3], melt(run$q0[-c(1:burn),])[,3])#
    color <- as.factor(melt(run$Means[-c(1:burn),])[,2])#
    raincol<-rainbow(length(levels(color)));    levels(color)<-raincol#
    trancol<-sapply(c(1:length(color)), function(x) adjustcolor(color[x], alpha.f=both[x,2]))#
    minmaxMEANS<-c(min(both[both[,2]>minq4PLOT ,1]), max(both[both[,2]>minq4PLOT ,1]))#
# PLOT 1#
slices <- prop.table(table((factor(emptyK, levels=c(1:K)))))#
Lab.palette <- colorRampPalette(rainbow(K*3, alpha=.3), space = "Lab")#
#
pdf(file=paste(simlabel, "_MCMCpp.pdf",sep='') ,width=8, height=3)#
    par(mfrow=c(1, 3))#
    barplot(slices, ylim=c(0,1), main="Estmated K_0", xlab="Number of non-empty states", ylab="Probability (from MCMC)") #
    abline(h=seq(0, 1, .05), lwd=0.5, col='LightGrey')#
    smoothScatter(both, colramp = Lab.palette, main="Posterior Surface", nrpoints = 0, xlab="Mean", ylab="Stationary dist.")#
    plot(both, col=trancol, xlim=minmaxMEANS, xlab="Mean", ylab="Stationary Distribution", bg='grey', main="Posterior Samples")#
    if(is.na(trueValues)==FALSE){   points(trueValues, pch=7, cex=2)}#
dev.off()#
# unswitch seperate groups and make indi plots#
Y<-run$YZ$Obs#
Grun<-TrimThin(run, burn, Thin=1)       #
targetK0<-Grun$K0#
K0<-as.numeric(names(table(targetK0 )))#
    n<-length(Y)  #
    K<-dim(Grun$q0)[2]  #
    p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0)/dim(Grun$q0)[1]), "RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)#
        grunK0<-Grun#
        # split data by K0#
for ( .K0 in 1:length(K0)){     #
        .iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred[-(n+1)]#
#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk(grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
            #RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance        #
        # print plot#
        #pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
        png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()#
        } # Close loop of >pmin#
        } # Close loop over each K0#
return(list(p_vals, K0estimates,Zestimates, USfullrun)) #
#
}
tv<-cbind("Mean"=c(0,3,10), "q0"=ALTERNATEq0(matrix( c(  0.2,0.3,0.5,    0.5,0.25,0.25,    0.25, 0.65, 0.1), nrow=3, byrow=T)))#
Zhmm_PP( run=s1_100_A1a001_First , burn=1000, prep=100, isSim=TRUE,trueValues=tv, minq4PLOT=0.0, simlabel="sim")
Zhmm_PP( run=s1_100_A1a001_First , burn=1000, prep=100, isSim=TRUE,trueValues=tv, minq4PLOT=0.05, simlabel="TESTMEzoe")
ls(0)
getwd()
setwd("..")
document()
document()
library(devtools); library(roxygen2)#
#
 install_github('zoevanhavre/Zhmm.0', auth_token='2fc7e2af77543d2a61981e945f6a67f6c4e59d7e')
library(Zhmm)
load('~/Google Drive/P3 HMMs/R Code/March22 Single VS PT/March23HomeSims.RDATA')
ls()
s3n100_mix1
library(Zhmm)
load('~/Google Drive/P3 HMMs/R Code/NewPTEasterWeekendsaturdayRun.RDATA')
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
Zhmm_PP<-function( run , burn=1000, prep=1000, isSim=TRUE,trueValues=NA, minq4PLOT=0.05, simlabel="sim"){#
    K<-dim(Run$q0)[2]#
    K0<-run$K0[burn:length(run$K0)]#
    K0estimates<-vector("list", length(K0))#
    Zestimates<-vector("list", length(K0))#
    USfullrun<-vector("list", length(K0))#
    # distribution of $K_0$#
    emptyK<-run$K0[burn:length(run$K0)]#
    # parameters by stationary dist#
    both<-cbind(melt(run$Means[-c(1:burn),])[,3], melt(run$q0[-c(1:burn),])[,3])#
    color <- as.factor(melt(run$Means[-c(1:burn),])[,2])#
    raincol<-rainbow(length(levels(color)));    levels(color)<-raincol#
    trancol<-sapply(c(1:length(color)), function(x) adjustcolor(color[x], alpha.f=both[x,2]))#
    minmaxMEANS<-c(min(both[both[,2]>minq4PLOT ,1]), max(both[both[,2]>minq4PLOT ,1]))#
# PLOT 1#
slices <- prop.table(table((factor(emptyK, levels=c(1:K)))))#
Lab.palette <- colorRampPalette(rainbow(K*3, alpha=.3), space = "Lab")#
#
pdf(file=paste(simlabel, "_MCMCpp.pdf",sep='') ,width=8, height=3)#
    par(mfrow=c(1, 3))#
    barplot(slices, ylim=c(0,1), main="Estmated K_0", xlab="Number of non-empty states", ylab="Probability (from MCMC)") #
    abline(h=seq(0, 1, .05), lwd=0.5, col='LightGrey')#
    smoothScatter(both, colramp = Lab.palette, main="Posterior Surface", nrpoints = 0, xlab="Mean", ylab="Stationary dist.")#
    plot(both, col=trancol, xlim=minmaxMEANS, xlab="Mean", ylab="Stationary Distribution", bg='grey', main="Posterior Samples")#
    if(is.na(trueValues)==FALSE){   points(trueValues, pch=7, cex=2)}#
dev.off()#
# unswitch seperate groups and make indi plots#
Y<-run$YZ$Obs#
Grun<-TrimThin(run, burn, Thin=1)       #
targetK0<-Grun$K0#
K0<-as.numeric(names(table(targetK0 )))#
    n<-length(Y)  #
    K<-dim(Grun$q0)[2]  #
    p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0)/dim(Grun$q0)[1]), "RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)#
        grunK0<-Grun#
        # split data by K0#
for ( .K0 in 1:length(K0)){     #
        .iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred[-(n+1)]#
#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk(grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
            #RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance        #
        # print plot#
        #pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
        png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()#
        } # Close loop of >pmin#
        } # Close loop over each K0#
return(list(p_vals, K0estimates,Zestimates, USfullrun)) #
#
}
setwd("/Users/zoevanhavre/Google Drive/P3 HMMs/R Code")
ls()
q1<-matrix(0.1, ncol=5, nrow=5)
diag(q1)<-.6
cbind("Mean"=c(-10, -5, 0, 5, 10), "q0"=ALTERNATEq0(q1))
tv3<-cbind("Mean"=c(-10, -5, 0, 5, 10), "q0"=ALTERNATEq0(q1))
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix1 , trueValues=tv3, simlabel="s3n100_mix1")
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
Zhmm_PP<-function( run , burn=1000, prep=1000, isSim=TRUE,trueValues=NA, minq4PLOT=0.05, simlabel="sim"){#
    K<-dim(run$q0)[2]#
    K0<-run$K0[burn:length(run$K0)]#
    K0estimates<-vector("list", length(K0))#
    Zestimates<-vector("list", length(K0))#
    USfullrun<-vector("list", length(K0))#
    # distribution of $K_0$#
    emptyK<-run$K0[burn:length(run$K0)]#
    # parameters by stationary dist#
    both<-cbind(melt(run$Means[-c(1:burn),])[,3], melt(run$q0[-c(1:burn),])[,3])#
    color <- as.factor(melt(run$Means[-c(1:burn),])[,2])#
    raincol<-rainbow(length(levels(color)));    levels(color)<-raincol#
    trancol<-sapply(c(1:length(color)), function(x) adjustcolor(color[x], alpha.f=both[x,2]))#
    minmaxMEANS<-c(min(both[both[,2]>minq4PLOT ,1]), max(both[both[,2]>minq4PLOT ,1]))#
# PLOT 1#
slices <- prop.table(table((factor(emptyK, levels=c(1:K)))))#
Lab.palette <- colorRampPalette(rainbow(K*3, alpha=.3), space = "Lab")#
#
pdf(file=paste(simlabel, "_MCMCpp.pdf",sep='') ,width=8, height=3)#
    par(mfrow=c(1, 3))#
    barplot(slices, ylim=c(0,1), main="Estmated K_0", xlab="Number of non-empty states", ylab="Probability (from MCMC)") #
    abline(h=seq(0, 1, .05), lwd=0.5, col='LightGrey')#
    smoothScatter(both, colramp = Lab.palette, main="Posterior Surface", nrpoints = 0, xlab="Mean", ylab="Stationary dist.")#
    plot(both, col=trancol, xlim=minmaxMEANS, xlab="Mean", ylab="Stationary Distribution", bg='grey', main="Posterior Samples")#
    if(is.na(trueValues)==FALSE){   points(trueValues, pch=7, cex=2)}#
dev.off()#
# unswitch seperate groups and make indi plots#
Y<-run$YZ$Obs#
Grun<-TrimThin(run, burn, Thin=1)       #
targetK0<-Grun$K0#
K0<-as.numeric(names(table(targetK0 )))#
    n<-length(Y)  #
    K<-dim(Grun$q0)[2]  #
    p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0)/dim(Grun$q0)[1]), "RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)#
        grunK0<-Grun#
        # split data by K0#
for ( .K0 in 1:length(K0)){     #
        .iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred[-(n+1)]#
#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk(grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
            #RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance        #
        # print plot#
        #pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
        png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()#
        } # Close loop of >pmin#
        } # Close loop over each K0#
return(list(p_vals, K0estimates,Zestimates, USfullrun)) #
#
}
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix1 , trueValues=tv3, simlabel="s3n100_mix1")
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
Zhmm_PP<-function( run , burn=1000, prep=1000, isSim=TRUE,trueValues=NA, minq4PLOT=0.05, simlabel="sim"){#
    K<-dim(run$q0)[2]#
    K0<-run$K0[burn:length(run$K0)]#
    K0estimates<-vector("list", length(K0))#
    Zestimates<-vector("list", length(K0))#
    USfullrun<-vector("list", length(K0))#
    # distribution of $K_0$#
    emptyK<-run$K0[burn:length(run$K0)]#
    # parameters by stationary dist#
    both<-cbind(melt(run$Means[-c(1:burn),])[,3], melt(run$q0[-c(1:burn),])[,3])#
    color <- as.factor(melt(run$Means[-c(1:burn),])[,2])#
    raincol<-rainbow(length(levels(color)));    levels(color)<-raincol#
    trancol<-sapply(c(1:length(color)), function(x) adjustcolor(color[x], alpha.f=both[x,2]))#
    minmaxMEANS<-c(min(both[both[,2]>minq4PLOT ,1]), max(both[both[,2]>minq4PLOT ,1]))#
# PLOT 1#
slices <- prop.table(table((factor(emptyK, levels=c(1:K)))))#
Lab.palette <- colorRampPalette(rainbow(K*3, alpha=.3), space = "Lab")#
#
pdf(file=paste(simlabel, "_MCMCpp.pdf",sep='') ,width=8, height=3)#
    par(mfrow=c(1, 3))#
    barplot(slices, ylim=c(0,1), main="Estmated K_0", xlab="Number of non-empty states", ylab="Probability (from MCMC)") #
    abline(h=seq(0, 1, .05), lwd=0.5, col='LightGrey')#
    smoothScatter(both, colramp = Lab.palette, main="Posterior Surface", nrpoints = 0, xlab="Mean", ylab="Stationary dist.")#
    plot(both, col=trancol, xlim=minmaxMEANS, xlab="Mean", ylab="Stationary Distribution", bg='grey', main="Posterior Samples")#
    if(is.na(trueValues)==FALSE){   points(trueValues, pch=7, cex=2)}#
dev.off()#
# unswitch seperate groups and make indi plots#
Y<-run$YZ$Obs#
Grun<-TrimThin(run, burn, Thin=1)       #
targetK0<-Grun$K0#
K0<-as.numeric(names(table(targetK0 )))#
    n<-length(Y)  #
    K<-dim(Grun$q0)[2]  #
    p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0)/dim(Grun$q0)[1]), "RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)#
        grunK0<-Grun#
        # split data by K0#
for ( .K0 in 1:length(K0)){     #
        .iterK0<- c(na.omit(c(1:dim(Grun$q0) [1])[targetK0 ==K0[.K0]]))#
    if(p_vals$PropIters[.K0]>0.05){#
        grunK0$Mu<- Grun$Means[.iterK0,]#
        grunK0$Q<-  Grun$Trans[.iterK0,]#
        grunK0$q0<- Grun$q0[.iterK0,]#
        grunK0$MAP<-Grun$MAP[.iterK0]#
        grunK0$Z<-  Grun$States[.iterK0,]#
        grunK0$K0<- Grun$K0[.iterK0]#
#
        ## 2. unswitch#
        grunK0us<-Zswitch_hmm(grunK0,0.05 )         #
        Zetc<-Zagg_HMM(grunK0us, Y)#
        K0estimates[[.K0]]<-cbind(Zetc$thetaCI, "K0"=K0[.K0])#
        Zestimates[[.K0]]<-Zetc$Zpred[-(n+1)]#
#
        q0.mean = aggregate(q0 ~ k, grunK0us$Pars, mean)#
        mu.mean = aggregate(mu ~ k, grunK0us$Pars, mean)#
#
        p1<-ggplot(data=grunK0us$Pars, aes(y=q0, x=factor(k))) + geom_boxplot(fill='lightblue',outlier.size=0.5)+ylab("Stationary dist.")+xlab("State")  +  theme(legend.position = "none")+theme_bw()+         ggtitle(bquote(atop(italic(paste( "p(K=", .(K0[.K0]), ")=", .(round(p_vals$PropIters[.K0],2)), sep="")), atop("Stationary distribution"))))+ geom_text(data =q0.mean, aes(label=signif(q0,4)),size=4,  col='red',vjust = 1)#
        p2<-ggplot(data=grunK0us$Pars, aes(y=mu, x=factor(k))) + geom_boxplot( fill='lightblue',outlier.size=0.5)+ylab("Mean")+xlab("State") +  theme(legend.position = "none")+theme_bw()+ggtitle( bquote(atop(italic(paste("Results for K=", .(K0[.K0]), sep="")), atop("Means"))))+geom_text(data =mu.mean, aes(label=signif(mu,4)),size=4,  col='red',vjust = 1)#
        #Allocations#
        p3<-HmmAllocationPlot(outZ=grunK0us$Z[,-(n+1)], myY=Y)#
        ## 4. Predict replicates#
        postPredTests<-PostPredFunk(grunK0us,Zetc, Y, 100, simlabel)#
        p4<-postPredTests$ggp   #
        # clusters:#
        plotyz<-data.frame("X"=1:n, "Y"=Y, "Post_Z"=Zetc$Zpred[-(n+1)])#
        p5<-ggplot(plotyz, aes(y=Y,x=X ))+geom_point(aes(colour=Post_Z),size=3)+ geom_line(alpha = 1/4)+theme_bw()+  theme(legend.position = "none")+ggtitle("Posterior Allocations")+xlab("Time") #
            #RAND       #
        if (isSim==TRUE){ p_vals$RAND<- sum(run$YZ$States==Zetc$Zpred)/length(Zetc$Zpred)}#
        p_vals$MAE[.K0]<- Zetc$MAE#
        p_vals$MSE[.K0]<- Zetc$MSE#
        p_vals$Pmin[.K0]<-postPredTests$MinP#
        p_vals$Pmax[.K0]<-postPredTests$MaxP#
        p_vals$MAPE[.K0]<-postPredTests$MAPE#
        p_vals$MSPE[.K0]<-postPredTests$MSPE#
        p_vals$Concordance[.K0]<-1-postPredTests$Concordance        #
        # print plot#
        #pdf( file= paste(simlabel, "K_ ",K0[.K0] , ".pdf",sep='') ,width=10, height=5)#
     if(p_vals$PropIters[.K0]==max(p_vals$PropIters)){#
        png( file= paste(simlabel, "K_ ",K0[.K0] , ".png",sep='') ,width=800, height=500)#
            print( wq::layOut(  list(p1,    1, 1:2),  #
                    list(p2,    1, 3:4),   #
                    list(p3,    1,5:6),#
                    list(p5,    2,1:3),  #
                    list(p4,    2,4:6)))#
        dev.off()#
    }#
        } # Close loop of >pmin#
        } # Close loop over each K0#
return(list(p_vals, K0estimates,Zestimates, USfullrun)) #
#
}
s3n100_1col1_pp<-Zhmm_PP( run=s3n100_1col1 , trueValues=tv3, simlabel="s3n100_1col1")
ls()
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix1 , trueValues=tv3, simlabel="s3n100_mix1")#
s3n100_mix10_pp<-Zhmm_PP( run=s3n100_mix10 , trueValues=tv3, simlabel="s3n100_mix10")#
s3n100_mixtheory_pp<-Zhmm_PP( run=s3n100_mixtheory , trueValues=tv3, simlabel="s3n100_mixtheory")#
#
s3n100_1col1_pp<-Zhmm_PP( run=s3n100_1col1 , trueValues=tv3, simlabel="s3n100_1col1")#
s3n100_1col10_pp<-Zhmm_PP( run=s3n100_1col10 , trueValues=tv3, simlabel="s3n100_1col10")#
s3n100_1coltheory_pp<-Zhmm_PP( run=s3n100_1coltheory , trueValues=tv3, simlabel="s3n100_1coltheory")
s3n500_mix1_pp<-Zhmm_PP( run=s3n500_mix1 , trueValues=tv3, simlabel="s3n500_mix1")#
s3n500_mix10_pp<-Zhmm_PP( run=s3n500_mix10 , trueValues=tv3, simlabel="s3n500_mix10")#
s3n500_mixtheory_pp<-Zhmm_PP( run=s3n500_mixtheory , trueValues=tv3, simlabel="s3n500_mixtheory")#
#
s3n500_1col1_pp<-Zhmm_PP( run=s3n500_1col1 , trueValues=tv3, simlabel="s3n500_1col1")#
s3n500_1col10_pp<-Zhmm_PP( run=s3n500_1col10 , trueValues=tv3, simlabel="s3n500_1col10")#
s3n500_1coltheory_pp<-Zhmm_PP( run=s3n500_1coltheory , trueValues=tv3, simlabel="s3n500_1coltheory")
getwd()
setwd("/Users/zoevanhavre/Google Drive/GitHub/Zhmm.0/R")
setwd("..")
document()
document()
document()
#' gibbsHMM_PT #
#'#
#' parallel tempering with a column prior - option to mix over column or stick to j=1#
#' @param x, alpha, log=False#
#' @keywords dirichlet#
#' @export#
#' @examples dDirichlet(c(.1, .9), c(0.1,0.1))#
gibbsHMM_PTnew<-function(YZ, M=2000, K=10 ,alphaMAX=1, type= 1, alphaMin=0.001, J=20, lab="sim"){#
    #____SET UP_________________________________________#
    ifelse(class(YZ)=='data.frame',    Y<-YZ$Observed, Y<-YZ)#
    n=length(Y) # sample size#
    varknown<-1 # known variace #
    mu0=0; var0=100#
     # INITIALIZE#
   # startVal<-makeStart(Y, K);  states0<-startVal$states0   #FUNK#
    states0<-replicate(J, list())#
    for(j in 1:J){states0[[j]]<-makeStartSimpler(Y, K)}#
#
     # J= number of chains#
        TrackParallelTemp<-matrix(nrow=M, ncol=J)#
         TrackParallelTemp[1,]<-c(1:J)#
      # TO BE INCORPORATED INTO J LISTS#
    MU<-replicate(J,  matrix(nrow=M, ncol=K),  simplify=F)#
    Q  <-replicate(J, matrix(nrow=M, ncol=K*K) , simplify=F)#
    Qold<- replicate(J, diag(K), simplify=F)#
    q0 <-replicate(J, matrix(nrow=M, ncol=K), simplify=F)#
    Z  <-replicate(J, matrix(nrow=M, ncol=n+1)  ,  simplify=F)  #include 0 for initial state to be estimated too?#
    SteadyScore<-data.frame("Iteration"=c(1:M), "K0"=K) ##### THIS IS NEW###
    PTsuccess  <- data.frame("Chain"=c(1:J),"Tries"=0,"Success"=0, "Ratio"=NA) #include 0 for initial state to be estimated too?#
    ntSTORE<-replicate(J, list())#
    K0Final<-matrix(nrow=M, ncol=J)#
    MAP<-c(1:M)  # KEEP TARGET ONLY#
    # ALPHA#
#
    #alphaMAX<-(K-1)*(1+K-2+alphaMin)*(1+1/( (1/2) - alphaMin*(K-1))) -(K-1)*alphaMin+0.1#
    Alpha_lows<-c(alphaMAX, exp(seq(log(alphaMAX), log(alphaMin), length=J))[-1])#
    #Store alphs for PT#
    STORE_Alphas<-replicate(J, list())#
    pb <- txtProgressBar(min = 0, max = M, style = 3)#
      #names(TrackParallelTemp)<-   AllAlphas[,2]#
    # functions#
    for (m in 1:M){ #
          if(m %% 100==0){Sys.sleep(0.1)#
            print(PTsuccess)#
          setTxtProgressBar(pb, m)#
                  if(M < 20001){    #
      #     par(mfrow=c(1,4))#
      #    plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l')#
      #    ts.plot(q0[[J]], main='q0 from target posterior', col=rainbow(K))#
      #    ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") )#
        #  axis(2, at=1:J, tick=1:J, labels=round(AllAlphas[,2],4), las=2) #
      #    axis(2, at=1:J, tick=1:J, labels=round(c(Alpha_lows),4), las=2)#
      #    image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
     par(mfrow=c(1,3))#
            plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l')#
            plot(as.vector(q0[[J]][c(m-99:m), ]), as.vector(MU[[J]][c(m-99:m), ]))#
              #, color=rgb(0,0,0,alpha=as.vector(q0[[J]])))#
           # image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
            ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") )#
            axis(2, at=1:J, tick=1:J, labels=round(c(Alpha_lows),4), las=2)#
          Sys.sleep(0)}}#
      for (j in 1:J){ # FOR EACH CHAIN           #
          # FOR EACH CHAIN...#
             # make matrix of alphas#
 AllAlphas<-matrix(Alpha_lows[j],ncol=K, nrow=K)   #
#
if (type==1){#
    AllAlphas[,1]<-alphaMAX      # make said column Amax#
}else if (type=="diag"){#
   diag(AllAlphas)<-alphaMAX #
}else if (type=="mix"){#
    if(sample( c(1, 0), size=1, prob=c(0.5, 0.5))==1){   # Put on diagonal#
      diag(AllAlphas)<-alphaMAX #
    } else {  #
      AllAlphas[,1]<-alphaMAX#
    }}#
            #  if(runif(1)>0.5){        AllAlphas[,1]<-alphaMAX      #
           #     }else{                    diag(AllAlphas)<-alphaMAX}#
                              # 1 Parameters given states Z(m-1)#
                      # 1.1  Transition matrix Q from conditional posterior#
                      if (m==1) {nt<-CountTrans(states0[[j]], K)#
                        } else { nt<-CountTrans(Z[[j]][m-1,],K)}   # HERE ACCESS STATES#
                          ntSTORE[[j]]<-nt#
                        # draw transition probs for state 1:K#
                    qnew<-matrix(ncol=K, nrow=K)#
                    for(k in 1:K){qnew[k,]<-rdirichlet(par=nt[k,]+AllAlphas[k,])}#
STORE_Alphas[[j]]<-AllAlphas#
    q0new <-  ALTERNATEq0(qnew)  #
#
                        #METROPOLIS Hastings STEP     #
              if (m>1){   #
                    q0Previous<-ALTERNATEq0(Qold[[j]])#
                    A<-q0new[Z[[j]][m-1,1]]/q0Previous[Z[[j]][m-1,1]]   #
                    # A<-q0new[Z[[j]][m-1,1]]/q0[[j]][m-1,Z[[j]][m-1,1]]   #
                                                            if(A=='NaN'){A<-0}     #
                    U<-runif(1,c(0,0.99))#
              if(A>runif(1,c(0,0.99))){  #  Accept new values#
                            Q[[j]][m,]<-as.vector(t(qnew))#
                            q0[[j]][m,]<-q0new#
              } else {  #Reject, chose OLD values of Q#
                            #Q[[j]][m,]<-as.vector(t(Q[[j]][m-1,]))#
                            Q[[j]][m,]<-as.vector(t(Qold[[j]]))#
#
                            #q0[[j]][m,]<-q0[[j]][m-1,]  #
                            q0[[j]][m,]<-q0Previous#
                            }#
              }else{ Q[[j]][m,]<-as.vector(t(qnew)) # 1st iteration always approved.#
                          q0[[j]][m,]<-q0new  }#
#
# new SAVE Qold for next iter        # **NEW**#
Qold[[j]]<-  matrix( Q[[j]][m,]  , K,K, byrow=TRUE)                     # **NEW**#
                        # 1.2 Update mu's    #
                        # compute needed values:  N(k) = number of times state k is visited in chain, and sum(y_k) = sum of y's in state k #
                        if (m==1) {sumNcount<-formu(states0[[j]][-(n+1)],Y,K)#
                        } else {sumNcount<-formu(Z[[j]][m-1,-(n+1)], Y,K)}   #
                           sumtot<-cbind(sumNcount$sumy, sumNcount$ny)                                                                                                    #       sums<-sumNcount$sumy ;    tots<-sumNcount$ny#
                      # new means          #
                      mudraw<-apply(sumtot, 1,  function (x)     rnorm(1, mean= ((mu0/var0)+(x[1]/varknown)) / ((1/var0)+(x[2]/varknown)), sd= sqrt( 1/( (1/var0) + (x[2]/varknown)))  ))#
                      MU[[j]][m,]<-mudraw  #
                    # 2 Update States given parameters#
                  newZ<- UpdateStates( Y, Q[[j]][m,], MU[[j]][m,], initS= q0[[j]][m,], m)#
                  Z[[j]][m,]<-newZ$Z#
                  if(j==J) MAP[m]<-newZ$MAP#
             } #end of PT chain loop#
## PT move#
#
          if(m>1) {TrackParallelTemp[m,]<-TrackParallelTemp[m-1,]}     #
          if(m>20){#
        #  if( sample(c(1,0),1, 0.9)==1){   # FREQ OF TEMPERING! #
## NEW, try each chain each time#
    #Chain1<-sample( 1:(J-1), 1)   #
    #Chain2<-Chain1+1#
       if (sample(c(1,0),1, prob=c(0.1,.9))==1){#
      if( m%%2==0){chainset<- c(1:(J-1))[c(1:(J-1))%%2==0]   #evens#
      } else {chainset<- c(1:(J-1))[c(1:(J-1))%%2!=0] }   #odds#
#
 for( eachChain in 1:length(chainset)){#
                Chain1<-chainset[eachChain]  #
                Chain2<-Chain1+1#
                 PTsuccess[Chain1,"Tries"]<-     PTsuccess[Chain1,"Tries"]+1#
                 PTsuccess[Chain2,"Tries"]<-     PTsuccess[Chain2,"Tries"]+1#
              Alpha1<-STORE_Alphas[[Chain1]]#
              Alpha2<-STORE_Alphas[[Chain2]]#
#
              Qchain1<-matrix(Q[[Chain1]][m,], nrow=K, byrow=TRUE)#
              Qchain2<- matrix(Q[[Chain2]][m,]   , nrow=K, byrow=TRUE)#
           MHratio<- parallelAcceptHMM_QV(Qchain1, Qchain2, Alpha1 ,Alpha2 , Z[[Chain1]][m,1], Z[[Chain2]][m,1])#
#
# ratio if ergodic only:    # MHratio<- parallelAcceptHMM_ergodic(Qchain1, Qchain2, Alpha1 ,Alpha2)#
            # MHratio<- parallelAcceptHMM_QV(Qchain1, Qchain2, Alpha1 ,Alpha2, Z[[Chain1]][m,1], Z[[Chain2]][m,1])#
          if (MHratio==1){                                 # switch #
          PTsuccess[Chain1,"Success"]<-PTsuccess[Chain1, "Success"]+1#
          PTsuccess[Chain2,"Success"]<-PTsuccess[Chain2, "Success"]+1#
                   #new#
                   .tpt1<-  TrackParallelTemp[m,Chain1 ]#
                   .tpt2<-  TrackParallelTemp[m,Chain2 ]             #
                  TrackParallelTemp[m,Chain1 ]<-.tpt2#
                  TrackParallelTemp[m,Chain2 ]<-.tpt1 #
          .p1<- q0[[Chain1]][m,]#
          .p2<- q0[[Chain2]][m,]#
          q0[[Chain1]][m,]<-.p2#
          q0[[Chain2]][m,]<-.p1#
          .m1<- MU[[Chain1]][m,]#
          .m2<- MU[[Chain2]][m,]#
          MU[[Chain1]][m,]<-.m2#
          MU[[Chain2]][m,]<-.m1#
          .s1<- Q[[Chain1]][m,]#
          .s2<- Q[[Chain2]][m,]#
          Q[[Chain1]][m,]<-.s2#
          Q[[Chain2]][m,]<-.s1#
          #ici#
.Qold1<- Qold[[Chain1]]#
.Qold2<- Qold[[Chain2]]#
          Qold[[Chain1]]<-.Qold2#
          Qold[[Chain2]]<-.Qold1#
                                                                                                                # Zs#
          .z1<- Z[[Chain1]][m,]#
          .z2<- Z[[Chain2]][m,]#
          Z[[Chain1]][m,]<-.z2#
          Z[[Chain2]][m,]<-.z1#
          }   }  #
         PTsuccess[,"Ratio"]<-apply(PTsuccess[,c(2,3)], 1, function(x) x[2]/x[1])#
              }}#
   SteadyScore$K0[m]<-sum(table(Z[[J]][m,])>0)#
#
# for all chains #
       K0Final[ m, ]<-sapply(   Z  ,  function(x)  sum(table(x[m,])>0))#
#
            }  # end of iteration loop#
close(pb)#
             PTsuccess[,"Ratio"]<-apply(PTsuccess[,c(2,3)], 1, function(x) x[2]/x[1])#
#
allResults<-list("Means"=MU[[J]], "Trans"=Q[[J]], "States"=Z[[J]], "q0"=q0[[J]], "YZ"=YZ, "MAP"=MAP, "K0"=SteadyScore$K0, "PTsuccess"=PTsuccess)#
#
            if(m ==M){Sys.sleep(0.01)#
      #   pdf( file=paste("HmmTracker_",lab, '.pdf', sep="") , height=4, width=12)#
          png( file=paste("HmmTracker_",lab, '.png', sep="") , height=400, width=1200)#
          par(mfrow=c(1,4))#
          plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l', ylab="K0")#
        MuXqoPlot( allResults, M/5, minq=0.01, plotlab=lab)  #
          ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") , ylab="alpha")#
         # axis(2, at=1:J, tick=1:J, labels=round(AllAlphas[,2],4), las=2) #
          axis(2, at=1:J, tick=1:J, labels=round(c( Alpha_lows),4), las=2) #
          #ts.plot(Bigmu[[nCh]], main='emptying Mu', col=rainbow(k))#
          image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
          #image(ZSaved[[nCh]][order(Y),], col=rainbow(K), main="Allocations")#
          dev.off()#
          Sys.sleep(0)}#
#
      return(allResults)#
      }
document()
document()
library(devtools); library(roxygen2)#
#
 install_github('zoevanhavre/Zhmm.0', auth_token='2fc7e2af77543d2a61981e945f6a67f6c4e59d7e')
s3n100_diag<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n100_diag' )#
s3n100_diag1_pp<-Zhmm_PP( run=s3n100_diag , trueValues=tv3, simlabel="s3n100_diag")#
s3n100_mix<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n100_mix' )#
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix , trueValues=tv3, simlabel="s3n100_mix")#
s3n100_mix_theory<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n100_mix_theory' )#
s3n100_mix1_theory_theory_pp<-Zhmm_PP( run=s3n100_mix_theory , trueValues=tv3, simlabel="s3n100_mix_theory")
s3n100_diag_theory<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n100_diag_theory' )#
s3n100_diag1_theory_pp<-Zhmm_PP( run=s3n100_diag_theory , trueValues=tv3, simlabel="s3n100_diag_theory")
#' gibbsHMM_PT #
#'#
#' parallel tempering with a column prior - option to mix over column or stick to j=1#
#' @param x, alpha, log=False#
#' @keywords dirichlet#
#' @export#
#' @examples dDirichlet(c(.1, .9), c(0.1,0.1))#
gibbsHMM_PTnew<-function(YZ, M=2000, K=10 ,alphaMAX=1, type= 1, alphaMin=0.001, J=20, lab="sim"){#
    #____SET UP_________________________________________#
    ifelse(class(YZ)=='data.frame',    Y<-YZ$Observed, Y<-YZ)#
    n=length(Y) # sample size#
    varknown<-1 # known variace #
    mu0=0; var0=100#
     # INITIALIZE#
   # startVal<-makeStart(Y, K);  states0<-startVal$states0   #FUNK#
    states0<-replicate(J, list())#
    for(j in 1:J){states0[[j]]<-makeStartSimpler(Y, K)}#
#
     # J= number of chains#
        TrackParallelTemp<-matrix(nrow=M, ncol=J)#
         TrackParallelTemp[1,]<-c(1:J)#
      # TO BE INCORPORATED INTO J LISTS#
    MU<-replicate(J,  matrix(nrow=M, ncol=K),  simplify=F)#
    Q  <-replicate(J, matrix(nrow=M, ncol=K*K) , simplify=F)#
    Qold<- replicate(J, diag(K), simplify=F)#
    q0 <-replicate(J, matrix(nrow=M, ncol=K), simplify=F)#
    Z  <-replicate(J, matrix(nrow=M, ncol=n+1)  ,  simplify=F)  #include 0 for initial state to be estimated too?#
    SteadyScore<-data.frame("Iteration"=c(1:M), "K0"=K) ##### THIS IS NEW###
    PTsuccess  <- data.frame("Chain"=c(1:J),"Tries"=0,"Success"=0, "Ratio"=NA) #include 0 for initial state to be estimated too?#
    ntSTORE<-replicate(J, list())#
    K0Final<-matrix(nrow=M, ncol=J)#
    MAP<-c(1:M)  # KEEP TARGET ONLY#
    # ALPHA#
#
    #alphaMAX<-(K-1)*(1+K-2+alphaMin)*(1+1/( (1/2) - alphaMin*(K-1))) -(K-1)*alphaMin+0.1#
    Alpha_lows<-c(alphaMAX, exp(seq(log(alphaMAX), log(alphaMin), length=J))[-1])#
    #Store alphs for PT#
    STORE_Alphas<-replicate(J, list())#
    pb <- txtProgressBar(min = 0, max = M, style = 3)#
      #names(TrackParallelTemp)<-   AllAlphas[,2]#
    # functions#
    for (m in 1:M){ #
          if(m %% 100==0){Sys.sleep(0.1)#
            print(PTsuccess)#
          setTxtProgressBar(pb, m)#
                  if(M < 20001){    #
      #     par(mfrow=c(1,4))#
      #    plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l')#
      #    ts.plot(q0[[J]], main='q0 from target posterior', col=rainbow(K))#
      #    ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") )#
        #  axis(2, at=1:J, tick=1:J, labels=round(AllAlphas[,2],4), las=2) #
      #    axis(2, at=1:J, tick=1:J, labels=round(c(Alpha_lows),4), las=2)#
      #    image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
     par(mfrow=c(1,3))#
            plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l')#
            plot(as.vector(q0[[J]][c(m-99:m), ]), as.vector(MU[[J]][c(m-99:m), ]))#
              #, color=rgb(0,0,0,alpha=as.vector(q0[[J]])))#
           # image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
            ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") )#
            axis(2, at=1:J, tick=1:J, labels=round(c(Alpha_lows),4), las=2)#
          Sys.sleep(0)}}#
      for (j in 1:J){ # FOR EACH CHAIN           #
          # FOR EACH CHAIN...#
             # make matrix of alphas#
 AllAlphas<-matrix(Alpha_lows[j],ncol=K, nrow=K)   #
#
if (type==1){#
    AllAlphas[,1]<-alphaMAX      # make said column Amax#
}else if (type=="diag"){#
   diag(AllAlphas)<-alphaMAX #
}else if (type=="mix"){#
    if(sample( c(1, 0), size=1, prob=c(0.5, 0.5))==1){   # Put on diagonal#
      diag(AllAlphas)<-alphaMAX #
    } else {  #
      AllAlphas[,1]<-alphaMAX#
    }}#
            #  if(runif(1)>0.5){        AllAlphas[,1]<-alphaMAX      #
           #     }else{                    diag(AllAlphas)<-alphaMAX}#
                              # 1 Parameters given states Z(m-1)#
                      # 1.1  Transition matrix Q from conditional posterior#
                      if (m==1) {nt<-CountTrans(states0[[j]], K)#
                        } else { nt<-CountTrans(Z[[j]][m-1,],K)}   # HERE ACCESS STATES#
                          ntSTORE[[j]]<-nt#
                        # draw transition probs for state 1:K#
                    qnew<-matrix(ncol=K, nrow=K)#
                    for(k in 1:K){qnew[k,]<-rdirichlet(par=nt[k,]+AllAlphas[k,])}#
STORE_Alphas[[j]]<-AllAlphas#
    q0new <-  ALTERNATEq0(qnew)  #
#
                        #METROPOLIS Hastings STEP     #
              if (m>1){   #
                    q0Previous<-ALTERNATEq0(Qold[[j]])#
                    A<-q0new[Z[[j]][m-1,1]]/q0Previous[Z[[j]][m-1,1]]   #
                    # A<-q0new[Z[[j]][m-1,1]]/q0[[j]][m-1,Z[[j]][m-1,1]]   #
                                                            if(A=='NaN'){A<-0}     #
                    U<-runif(1,c(0,0.99))#
              if(A>runif(1,c(0,0.99))){  #  Accept new values#
                            Q[[j]][m,]<-as.vector(t(qnew))#
                            q0[[j]][m,]<-q0new#
              } else {  #Reject, chose OLD values of Q#
                            #Q[[j]][m,]<-as.vector(t(Q[[j]][m-1,]))#
                            Q[[j]][m,]<-as.vector(t(Qold[[j]]))#
#
                            #q0[[j]][m,]<-q0[[j]][m-1,]  #
                            q0[[j]][m,]<-q0Previous#
                            }#
              }else{ Q[[j]][m,]<-as.vector(t(qnew)) # 1st iteration always approved.#
                          q0[[j]][m,]<-q0new  }#
#
# new SAVE Qold for next iter        # **NEW**#
Qold[[j]]<-  matrix( Q[[j]][m,]  , K,K, byrow=TRUE)                     # **NEW**#
                        # 1.2 Update mu's    #
                        # compute needed values:  N(k) = number of times state k is visited in chain, and sum(y_k) = sum of y's in state k #
                        if (m==1) {sumNcount<-formu(states0[[j]][-(n+1)],Y,K)#
                        } else {sumNcount<-formu(Z[[j]][m-1,-(n+1)], Y,K)}   #
                           sumtot<-cbind(sumNcount$sumy, sumNcount$ny)                                                                                                    #       sums<-sumNcount$sumy ;    tots<-sumNcount$ny#
                      # new means          #
                      mudraw<-apply(sumtot, 1,  function (x)     rnorm(1, mean= ((mu0/var0)+(x[1]/varknown)) / ((1/var0)+(x[2]/varknown)), sd= sqrt( 1/( (1/var0) + (x[2]/varknown)))  ))#
                      MU[[j]][m,]<-mudraw  #
                    # 2 Update States given parameters#
                  newZ<- UpdateStates( Y, Q[[j]][m,], MU[[j]][m,], initS= q0[[j]][m,], m)#
                  Z[[j]][m,]<-newZ$Z#
                  if(j==J) MAP[m]<-newZ$MAP#
             } #end of PT chain loop#
## PT move#
#
          if(m>1) {TrackParallelTemp[m,]<-TrackParallelTemp[m-1,]}     #
          if(m>20){#
        #  if( sample(c(1,0),1, 0.9)==1){   # FREQ OF TEMPERING! #
## NEW, try each chain each time#
    #Chain1<-sample( 1:(J-1), 1)   #
    #Chain2<-Chain1+1#
       if (sample(c(1,0),1, prob=c(0.9,.1))==1){#
      if( m%%2==0){chainset<- c(1:(J-1))[c(1:(J-1))%%2==0]   #evens#
      } else {chainset<- c(1:(J-1))[c(1:(J-1))%%2!=0] }   #odds#
#
 for( eachChain in 1:length(chainset)){#
                Chain1<-chainset[eachChain]  #
                Chain2<-Chain1+1#
                 PTsuccess[Chain1,"Tries"]<-     PTsuccess[Chain1,"Tries"]+1#
                 PTsuccess[Chain2,"Tries"]<-     PTsuccess[Chain2,"Tries"]+1#
              Alpha1<-STORE_Alphas[[Chain1]]#
              Alpha2<-STORE_Alphas[[Chain2]]#
#
              Qchain1<-matrix(Q[[Chain1]][m,], nrow=K, byrow=TRUE)#
              Qchain2<- matrix(Q[[Chain2]][m,]   , nrow=K, byrow=TRUE)#
           MHratio<- parallelAcceptHMM_QV(Qchain1, Qchain2, Alpha1 ,Alpha2 , Z[[Chain1]][m,1], Z[[Chain2]][m,1])#
#
# ratio if ergodic only:    # MHratio<- parallelAcceptHMM_ergodic(Qchain1, Qchain2, Alpha1 ,Alpha2)#
            # MHratio<- parallelAcceptHMM_QV(Qchain1, Qchain2, Alpha1 ,Alpha2, Z[[Chain1]][m,1], Z[[Chain2]][m,1])#
          if (MHratio==1){                                 # switch #
          PTsuccess[Chain1,"Success"]<-PTsuccess[Chain1, "Success"]+1#
          PTsuccess[Chain2,"Success"]<-PTsuccess[Chain2, "Success"]+1#
                   #new#
                   .tpt1<-  TrackParallelTemp[m,Chain1 ]#
                   .tpt2<-  TrackParallelTemp[m,Chain2 ]             #
                  TrackParallelTemp[m,Chain1 ]<-.tpt2#
                  TrackParallelTemp[m,Chain2 ]<-.tpt1 #
          .p1<- q0[[Chain1]][m,]#
          .p2<- q0[[Chain2]][m,]#
          q0[[Chain1]][m,]<-.p2#
          q0[[Chain2]][m,]<-.p1#
          .m1<- MU[[Chain1]][m,]#
          .m2<- MU[[Chain2]][m,]#
          MU[[Chain1]][m,]<-.m2#
          MU[[Chain2]][m,]<-.m1#
          .s1<- Q[[Chain1]][m,]#
          .s2<- Q[[Chain2]][m,]#
          Q[[Chain1]][m,]<-.s2#
          Q[[Chain2]][m,]<-.s1#
          #ici#
.Qold1<- Qold[[Chain1]]#
.Qold2<- Qold[[Chain2]]#
          Qold[[Chain1]]<-.Qold2#
          Qold[[Chain2]]<-.Qold1#
                                                                                                                # Zs#
          .z1<- Z[[Chain1]][m,]#
          .z2<- Z[[Chain2]][m,]#
          Z[[Chain1]][m,]<-.z2#
          Z[[Chain2]][m,]<-.z1#
          }   }  #
         PTsuccess[,"Ratio"]<-apply(PTsuccess[,c(2,3)], 1, function(x) x[2]/x[1])#
              }}#
   SteadyScore$K0[m]<-sum(table(Z[[J]][m,])>0)#
#
# for all chains #
       K0Final[ m, ]<-sapply(   Z  ,  function(x)  sum(table(x[m,])>0))#
#
            }  # end of iteration loop#
close(pb)#
             PTsuccess[,"Ratio"]<-apply(PTsuccess[,c(2,3)], 1, function(x) x[2]/x[1])#
#
allResults<-list("Means"=MU[[J]], "Trans"=Q[[J]], "States"=Z[[J]], "q0"=q0[[J]], "YZ"=YZ, "MAP"=MAP, "K0"=SteadyScore$K0, "PTsuccess"=PTsuccess)#
#
            if(m ==M){Sys.sleep(0.01)#
      #   pdf( file=paste("HmmTracker_",lab, '.pdf', sep="") , height=4, width=12)#
          png( file=paste("HmmTracker_",lab, '.png', sep="") , height=400, width=1200)#
          par(mfrow=c(1,4))#
          plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l', ylab="K0")#
        MuXqoPlot( allResults, M/5, minq=0.01, plotlab=lab)  #
          ts.plot(TrackParallelTemp, main='Track Parallel Tempering', col=rainbow(J), gpars=list(yaxt="n") , ylab="alpha")#
         # axis(2, at=1:J, tick=1:J, labels=round(AllAlphas[,2],4), las=2) #
          axis(2, at=1:J, tick=1:J, labels=round(c( Alpha_lows),4), las=2) #
          #ts.plot(Bigmu[[nCh]], main='emptying Mu', col=rainbow(k))#
          image(Z[[J]][,order(Y)], col=rainbow(K), main="Allocations vs ordered Y")#
          #image(ZSaved[[nCh]][order(Y),], col=rainbow(K), main="Allocations")#
          dev.off()#
          Sys.sleep(0)}#
#
      return(allResults)#
      }
s3n100_diag<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n100_diag' )#
s3n100_diag1_pp<-Zhmm_PP( run=s3n100_diag , trueValues=tv3, simlabel="s3n100_diag")#
s3n100_mix<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n100_mix' )#
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix , trueValues=tv3, simlabel="s3n100_mix")#
s3n100_mix_theory<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n100_mix_theory' )#
s3n100_mix1_theory_theory_pp<-Zhmm_PP( run=s3n100_mix_theory , trueValues=tv3, simlabel="s3n100_mix_theory")#
s3n100_diag_theory<-gibbsHMM_PTnew(s3_n100, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n100_diag_theory' )#
s3n100_diag1_theory_pp<-Zhmm_PP( run=s3n100_diag_theory , trueValues=tv3, simlabel="s3n100_diag_theory")
q1<-matrix(0.1, ncol=5, nrow=5)#
diag(q1)<-.6#
tv3<-cbind("Mean"=c(-10, -5, 0, 5, 10), "q0"=ALTERNATEq0(q1))
s3n100_diag1_pp<-Zhmm_PP( run=s3n100_diag , trueValues=tv3, simlabel="s3n100_diag")#
#
s3n100_mix1_pp<-Zhmm_PP( run=s3n100_mix , trueValues=tv3, simlabel="s3n100_mix")#
#
s3n100_mix1_theory_theory_pp<-Zhmm_PP( run=s3n100_mix_theory , trueValues=tv3, simlabel="s3n100_mix_theory")#
#
s3n100_diag1_theory_pp<-Zhmm_PP( run=s3n100_diag_theory , trueValues=tv3, simlabel="s3n100_diag_theory")
s3n500_diag<-gibbsHMM_PTnew(s3_n500, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n500_diag' )#
s3n500_diag1_pp<-Zhmm_PP( run=s3n500_diag , trueValues=tv3, simlabel="s3n500_diag")#
s3n500_mix<-gibbsHMM_PTnew(s3_n500, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n500_mix' )#
s3n500_mix1_pp<-Zhmm_PP( run=s3n500_mix , trueValues=tv3, simlabel="s3n500_mix")#
s3n500_mix_theory<-gibbsHMM_PTnew(s3_n500, M=2000, K=10, alphaMAX=1, type="mix", alphaMin=0.001, J=20, lab='s3n500_mix_theory' )#
s3n500_mix1_theory_theory_pp<-Zhmm_PP( run=s3n500_mix_theory , trueValues=tv3, simlabel="s3n500_mix_theory")#
s3n500_diag_theory<-gibbsHMM_PTnew(s3_n500, M=2000, K=10, alphaMAX=1, type="diag", alphaMin=0.001, J=20, lab='s3n500_diag_theory' )#
s3n500_diag1_theory_pp<-Zhmm_PP( run=s3n500_diag_theory , trueValues=tv3, simlabel="s3n500_diag_theory")
document()
document()
save.image("MixAndDiagTetsEaster.RDATA")
